# Tauri Desktop Integration

## 1. Purpose

Tauri integration provides native desktop capabilities for the MCP Hub application, including MCP process lifecycle management, secure credential storage, file dialogs, and auto-updates. The desktop build bundles a full Next.js server runtime instead of using static export, enabling SSR features and dynamic server-side functionality.

## 2. How it Works

### Desktop vs Web Architecture
- **Web mode** (`pnpm dev`): Next.js dev server on `localhost:3000`, MCP processes managed via Node.js `child_process`
- **Desktop mode** (`pnpm tauri dev`): Tauri window spawns embedded Next.js server on port 34115, MCP processes managed via Rust Command API

### Build & Bundling Strategy
The custom build script (`scripts/tauri-build.js`) avoids Next.js `standalone` output (which causes Windows symlink errors):
1. Produces regular `.next/` output (not standalone with symlinks)
2. Generates minimal Node.js launcher: `src-tauri/resources/server.js`
3. Copies host Node.js binary to `src-tauri/resources/node/`
4. Tauri bundles these resources into MSI installer

**Key insight**: Desktop app runs full Next.js server, not static export. This requires:
- Images: `unoptimized: true` (no Next.js Image optimization in bundled mode)
- Asset prefix: `http://localhost:3000` in dev, undefined in prod (uses file://)

### Process Lifecycle Management
**Stdio servers (managed by Tauri)**:
- Frontend component triggers lifecycle command via `lib/services/tauri-bridge.ts`
- `src-tauri/src/mcp_lifecycle.rs` spawns/stops child process using Rust `Command` API
- Process states: `stopped` → `starting` → `running` → `stopping` → `stopped`
- Rust backend monitors status and reports back to frontend via IPC

**Remote servers (HTTP/SSE)**:
- No Tauri involvement; managed directly by `lib/services/mcp-client.ts`

### Runtime Detection
`lib/services/tauri-bridge.ts` provides conditional invocation:
```typescript
if (isTauri()) {
  // Desktop: invoke Rust commands
  const status = await invoke('get_server_status', { id });
} else {
  // Web: fallback implementations (localStorage, web socket, etc.)
}
```

## 3. Relevant Code Modules

- `/scripts/tauri-build.js` - Custom Next.js bundling for Tauri
- `/src-tauri/src/lib.rs` - Tauri command entry point and handler registration
- `/src-tauri/src/mcp_lifecycle.rs` - MCP server process lifecycle (start/stop/restart)
- `/src-tauri/tauri.conf.json` - Tauri app manifest, bundle config, window settings
- `/src-tauri/Cargo.toml` - Rust dependencies, Tauri version (2.9)
- `/lib/services/tauri-bridge.ts` - Runtime detection and command invocation wrapper
- `/lib/services/mcp-process-manager.ts` - Fallback Node.js process manager (web mode)
- `/next.config.ts` - Next.js configuration for bundled server mode
- `/eslint.config.mjs` - Linter rules excluding Rust build output

## 4. Attention

1. **MSI-only bundle**: `tauri.conf.json` restricts `bundle.targets` to `["msi"]` to avoid NSIS timeout issues
2. **No standalone output**: Next.js `output: "standalone"` is disabled; uses regular `.next/` + custom launcher
3. **Node.js bundling**: Script gracefully degrades if binary copy fails; system Node will be used at runtime
4. **Conditional imports**: Always use `tauri-bridge.ts` wrapper for runtime safety; never import Tauri APIs directly without `isTauri()` check
5. **Generated server launcher**: `src-tauri/resources/server.js` is auto-generated by build script; do not manually edit
